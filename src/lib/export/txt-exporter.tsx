import type { DocumentData, Exporter } from "./index";

/**
 * Plain Text Exporter Implementation
 * Exports documents to plain text format
 */
export class TxtExporter implements Exporter {
    async export(data: DocumentData): Promise<Buffer> {
        let text = "";
        const separator = "=".repeat(60) + "\n";
        const subSeparator = "-".repeat(40) + "\n";

        // Title
        text += separator;
        text += this.centerText(data.title.toUpperCase(), 60) + "\n";
        text += this.centerText(data.type, 60) + "\n";
        text += separator + "\n";

        // Metadata
        text += "DOCUMENT INFORMATION\n";
        text += subSeparator;
        text += `Created:     ${this.formatDate(data.metadata.createdAt)}\n`;
        if (data.metadata.completedAt) {
            text += `Completed:   ${this.formatDate(data.metadata.completedAt)}\n`;
        }
        text += `Word Count:  ${data.metadata.wordCount.toLocaleString()}\n`;
        if (data.metadata.author) {
            text += `Author:      ${data.metadata.author}\n`;
        }
        text += "\n" + separator + "\n";

        // Table of Contents
        text += "TABLE OF CONTENTS\n";
        text += subSeparator;
        const sortedSections = [...data.sections].sort((a, b) => a.order - b.order);
        sortedSections.forEach((section, index) => {
            text += `  ${index + 1}. ${section.name}\n`;
        });
        text += "\n" + separator + "\n";

        // Content
        sortedSections.forEach((section, index) => {
            text += `\n${index + 1}. ${section.name.toUpperCase()}\n`;
            text += subSeparator + "\n";
            text += this.formatTextContent(section.content);
            text += "\n\n";
        });

        // Footer
        text += separator;
        text += this.centerText(
            `Generated by DocuForge on ${this.formatDate(new Date())}`,
            60
        );

        return Buffer.from(text, "utf-8");
    }

    getMimeType(): string {
        return "text/plain";
    }

    getFileExtension(): string {
        return "txt";
    }

    private formatDate(date: Date): string {
        return new Date(date).toLocaleDateString("en-US", {
            year: "numeric",
            month: "long",
            day: "numeric",
        });
    }

    private centerText(text: string, width: number): string {
        const padding = Math.max(0, Math.floor((width - text.length) / 2));
        return " ".repeat(padding) + text;
    }

    private formatTextContent(content: string): string {
        // Clean up the content for plain text
        let formatted = content;

        // Remove any markdown formatting
        formatted = formatted.replace(/\*\*(.+?)\*\*/g, "$1");
        formatted = formatted.replace(/\*(.+?)\*/g, "$1");
        formatted = formatted.replace(/^#+\s*/gm, "");

        // Ensure proper line wrapping
        const maxLineLength = 80;
        const paragraphs = formatted.split("\n\n");

        return paragraphs
            .map((paragraph) => {
                // Handle lists specially
                if (paragraph.trim().startsWith("- ") || paragraph.trim().startsWith("â€¢ ")) {
                    return paragraph
                        .split("\n")
                        .map((item) => this.wrapText(item, maxLineLength, "  "))
                        .join("\n");
                }

                // Regular paragraphs
                return this.wrapText(paragraph, maxLineLength);
            })
            .join("\n\n");
    }

    private wrapText(text: string, maxLength: number, indent: string = ""): string {
        const words = text.split(" ");
        const lines: string[] = [];
        let currentLine = indent;

        for (const word of words) {
            if (currentLine.length + word.length + 1 > maxLength) {
                lines.push(currentLine);
                currentLine = indent + word;
            } else {
                currentLine += (currentLine.length > indent.length ? " " : "") + word;
            }
        }

        if (currentLine.length > indent.length) {
            lines.push(currentLine);
        }

        return lines.join("\n");
    }
}