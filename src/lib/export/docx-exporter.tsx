//src/lib/export/docx-exporter.tsx

import {
    Document,
    Paragraph,
    TextRun,
    HeadingLevel,
    AlignmentType,
    PageBreak,
    Table,
    TableRow,
    TableCell,
    WidthType,
    BorderStyle,
    Packer,
    type IPropertiesOptions,
    Footer,
    Header,
    PageNumber,
    NumberFormat,
} from "docx";
import type { DocumentData, Exporter } from "./index";

/**
 * DOCX Exporter Implementation
 * Uses the docx library to create Word documents
 */
export class DocxExporter implements Exporter {
    async export(data: DocumentData): Promise<Buffer> {
        // Document properties
        const properties: IPropertiesOptions = {
            creator: data.metadata.author ?? "DocuForge",
            title: data.title,
            description: `${data.type} generated by DocuForge`,
            keywords: data.type,
            lastModifiedBy: data.metadata.author ?? "DocuForge",
        };

        // Create document sections
        const sections = [];

        // Title page
        sections.push({
            properties: {},
            children: [
                // Title
                new Paragraph({
                    text: data.title,
                    heading: HeadingLevel.TITLE,
                    alignment: AlignmentType.CENTER,
                    spacing: {
                        after: 400,
                    },
                }),
                // Document type
                new Paragraph({
                    text: data.type,
                    alignment: AlignmentType.CENTER,
                    spacing: {
                        after: 200,
                    },
                }),
                // Metadata
                new Paragraph({
                    text: `Created: ${this.formatDate(data.metadata.createdAt)}`,
                    alignment: AlignmentType.CENTER,
                    spacing: {
                        after: 100,
                    },
                }),
                new Paragraph({
                    text: `Word Count: ${data.metadata.wordCount.toLocaleString()}`,
                    alignment: AlignmentType.CENTER,
                    spacing: {
                        after: 100,
                    },
                }),
                ...(data.metadata.author
                    ? [
                        new Paragraph({
                            text: `Author: ${data.metadata.author}`,
                            alignment: AlignmentType.CENTER,
                            spacing: {
                                after: 100,
                            },
                        }),
                    ]
                    : []),
                new PageBreak(),
                // Table of Contents
                new Paragraph({
                    text: "Table of Contents",
                    heading: HeadingLevel.HEADING_1,
                    spacing: {
                        after: 300,
                    },
                }),
                ...this.createTableOfContents(data.sections),
                new PageBreak(),
            ],
        });

        // Content sections
        const sortedSections = [...data.sections].sort((a, b) => a.order - b.order);
        const contentChildren = [];

        for (let i = 0; i < sortedSections.length; i++) {
            const section = sortedSections[i];

            // Section heading
            contentChildren.push(
                new Paragraph({
                    text: `${i + 1}. ${section.name}`,
                    heading: HeadingLevel.HEADING_1,
                    spacing: {
                        before: 400,
                        after: 200,
                    },
                })
            );

            // Section content
            const contentParagraphs = this.parseContent(section.content);
            contentChildren.push(...contentParagraphs);

            // Add page break between sections (except for the last one)
            if (i < sortedSections.length - 1) {
                contentChildren.push(new PageBreak());
            }
        }

        // Add content section with headers and footers
        sections.push({
            properties: {
                page: {
                    margin: {
                        top: 1440, // 1 inch
                        right: 1440,
                        bottom: 1440,
                        left: 1440,
                    },
                },
            },
            headers: {
                default: new Header({
                    children: [
                        new Paragraph({
                            text: data.title,
                            alignment: AlignmentType.RIGHT,
                            style: "headerStyle",
                        }),
                    ],
                }),
            },
            footers: {
                default: new Footer({
                    children: [
                        new Paragraph({
                            alignment: AlignmentType.CENTER,
                            children: [
                                new TextRun({
                                    children: ["Page ", PageNumber.CURRENT, " of ", PageNumber.TOTAL_PAGES],
                                }),
                            ],
                        }),
                    ],
                }),
            },
            children: contentChildren,
        });

        // Create document
        const doc = new Document({
            creator: properties.creator,
            title: properties.title,
            description: properties.description,
            styles: {
                default: {
                    heading1: {
                        run: {
                            size: 32,
                            bold: true,
                        },
                        paragraph: {
                            spacing: {
                                after: 200,
                            },
                        },
                    },
                    heading2: {
                        run: {
                            size: 26,
                            bold: true,
                        },
                        paragraph: {
                            spacing: {
                                after: 150,
                            },
                        },
                    },
                },
                paragraphStyles: [
                    {
                        id: "normal",
                        name: "Normal",
                        run: {
                            size: 22, // 11pt
                        },
                        paragraph: {
                            spacing: {
                                after: 120,
                                line: 360, // 1.5 line spacing
                            },
                        },
                    },
                    {
                        id: "headerStyle",
                        name: "Header",
                        run: {
                            size: 20,
                            italics: true,
                        },
                    },
                ],
            },
            sections,
            numbering: {
                config: [
                    {
                        reference: "bullet-list",
                        levels: [
                            {
                                level: 0,
                                format: NumberFormat.BULLET,
                                text: "•",
                                alignment: AlignmentType.LEFT,
                                style: {
                                    paragraph: {
                                        indent: { left: 720, hanging: 360 },
                                    },
                                },
                            },
                        ],
                    },
                ],
            },
        });

        // Generate buffer
        const buffer = await Packer.toBuffer(doc);
        return Buffer.from(buffer);
    }

    getMimeType(): string {
        return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    }

    getFileExtension(): string {
        return "docx";
    }

    private formatDate(date: Date): string {
        return new Date(date).toLocaleDateString("en-US", {
            year: "numeric",
            month: "long",
            day: "numeric",
        });
    }

    private createTableOfContents(sections: any[]): Paragraph[] {
        const sortedSections = [...sections].sort((a, b) => a.order - b.order);

        return sortedSections.map(
            (section, index) =>
                new Paragraph({
                    text: `${index + 1}. ${section.name}`,
                    style: "normal",
                    spacing: {
                        after: 100,
                    },
                    indent: {
                        left: 360,
                    },
                })
        );
    }

    private parseContent(content: string): Paragraph[] {
        const paragraphs: Paragraph[] = [];
        const lines = content.split("\n\n").filter((p) => p.trim());

        for (const line of lines) {
            // Check if it's a heading (starts with #)
            if (line.startsWith("#")) {
                const level = (/^#+/.exec(line))?.[0].length || 1;
                const text = line.replace(/^#+\s*/, "");

                paragraphs.push(
                    new Paragraph({
                        text,
                        heading: level === 1 ? HeadingLevel.HEADING_2 : HeadingLevel.HEADING_3,
                    })
                );
            }
            // Check if it's a list
            else if (line.trim().startsWith("- ") || line.trim().startsWith("• ")) {
                const items = line.split("\n").filter((item) => item.trim());

                for (const item of items) {
                    const text = item.replace(/^[-•]\s*/, "");
                    paragraphs.push(
                        new Paragraph({
                            text,
                            style: "normal",
                            numbering: {
                                reference: "bullet-list",
                                level: 0,
                            },
                        })
                    );
                }
            }
            // Check if it's bold text
            else if (line.includes("**")) {
                const runs: TextRun[] = [];
                const parts = line.split(/\*\*/);

                for (let i = 0; i < parts.length; i++) {
                    runs.push(
                        new TextRun({
                            text: parts[i],
                            bold: i % 2 === 1, // Odd indices are bold
                        })
                    );
                }

                paragraphs.push(
                    new Paragraph({
                        children: runs,
                        style: "normal",
                    })
                );
            }
            // Regular paragraph
            else {
                paragraphs.push(
                    new Paragraph({
                        text: line,
                        style: "normal",
                    })
                );
            }
        }

        return paragraphs;
    }
}